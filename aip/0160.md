---
aip:
  id: 160
  state: reviewing
  created: 2020-02-24
permalink: /160
redirect_from:
  - /0160
---

# Filtering

Often, when listing resources (using a list method as defined in [AIP-132][] or
something reasonably similar), it is desirable to filter over the collection
and only return results that the user is interested in.

It is tempting to define a structure to handle the precise filtering needs for
each API. However, filtering requirements evolve frequently, and therefore it
is prudent to use a string field with a structured syntax accessible to a
non-technical audience. This allows updates to be able to be made
transparently, without waiting for UI or client updates.

**Note:** Because list filters are intended for a potentially non-technical
audience, they sometimes borrow from patterns of colloquial speech rather than
common patterns found in code.

## Guidance

APIs **may** provide filtering to users on `List` methods (or similar methods
to query a collection, such as `Search`). If they choose to do so, they
**must** follow the common specification for filters discussed here. The syntax
is formally defined in the [EBNF grammar][].

**Note:** Google provides implementations for the filtering language in both
[C++][cel-cpp] and [Go][cel-go] as a discrete component of [CEL][]. The use of
these implementations is encouraged.

### Expressions

Expressions are literal values in the filtering syntax ("42", "Victor Hugo").
Expressions can be pieced together with operators to make other expressions.

### Logical Operators

Filtering implementations **must** provide the binary operators `AND` and `OR`,
as well as a whitespace operator:

| Operator | Example       | Meaning                                |
| -------- | ------------- | -------------------------------------- |
| `AND`    | `a AND b`     | True if `a` and `b` are true.          |
| `OR`     | `a OR b OR c` | True if any of `a`, `b`, `c` are true. |

The whitespace operator (example: `a b c`) represents a fuzzy variant of `AND`,
which is suitable for result ranking and term rewrite.

**Note:** To match common patterns of speech, the `OR` operator has higher
precedence than `AND`, unlike what is found in most programming languages. The
expression `a AND b OR c` evaluates: `a AND (b OR c)`. API documentation and
examples **should** encourage the use of explicit parentheses to avoid
confusion.

### Negation Operators

Filtering implementations **must** provide the unary operators `NOT` and `-`.
These are used interchangeably.

| Operator | Example | Meaning                  |
| -------- | ------- | ------------------------ |
| `NOT`    | `NOT a` | True if `a` is not true. |
| `-`      | `-a`    | True if `a` is not true. |

### Comparison Operators

Filtering implementations **must** provide the binary comparison operators `=`,
`!=`, `<`, `>`, `<=`, and `>=`.

| Operator | Example      | Meaning                                         |
| -------- | ------------ | ----------------------------------------------- |
| `=`      | `a = true`   | True if `a` is true.                            |
| `!=`     | `a != 42`    | True unless `a` equals 42.                      |
| `<`      | `a < 42`     | True if `a` is a numeric value below 42.        |
| `>`      | `a > "foo"`  | True if `a` is lexically ordered after "foo".   |
| `<=`     | `a <= "foo"` | True if `a` is "foo" or lexically before it.    |
| `>=`     | `a >= 42`    | True if `a` is a numeric value of 42 or higher. |

Because filters are accepted as querty strings, type conversion takes place to
translate the string to the appropriate strongly-typed value:

- Enums expect the enum's string representation (case-sensitive).
- Booleans expect `true` and `false` literal values.
- Numbers expect the standard integer or float representations. For floats,
  exponents are supported (e.g. `2.997e9`).
- [Durations][] expect a numeric representation followed by an `s` suffix (for
  seconds). Examples: `20s`, `1.2s`.
- [Timestamps][] expect an [RFC-3339][] formatted string (e.g.
  `2012-04-21T11:30:00-0400`). Timezones are supported.

**Warning:** The identifiers `true`, `false`, and `null` only carry intrinsic
meaning when used in the context of a typed field reference.

Additionally, when comparing strings for equality, the `*` character denotes
wildcard syntax; for example, `a = "*.foo"` is true if `a` _ends with_ ".foo".

### Traversal operator

Filtering implementations **must** provide the `.` operator, which indicates
traversal through a message, map, or struct.

| Example         | Meaning                                               |
| --------------- | ----------------------------------------------------- |
| `a.b = true`    | True if `a` has a boolean `b` field that is true.     |
| `a.b > 42`      | True if `a` has a numeric `b` field that is above 42. |
| `a.b.c = "foo"` | True if `a.b` has a string `c` field that is "foo".   |

**Important:** The `.` operator **must not** be used to traverse through a
repeated field or list, except for specific use with the `:` operator.

### Has Operator

Filtering implementations **must** provide the `:` operator, which means "has".
It is usable with collections (repeated fields or maps) as well as messages,
and behaves slightly differently in each case.

Repeated fields query to see if the repeated structure contains a matching
element:

| Example    | Meaning                                                     |
| ---------- | ----------------------------------------------------------- |
| `r:42`     | True if `r` contains 42.                                    |
| `r.foo:42` | True if `r` contains an element `e` such that `e.foo = 42`. |

**Important:** Filters can not query a _specific_ element on a repeated field
for a value. For example, `e.0.foo = 42` is **not** a valid filter.

Maps, structs, messages can query either for the presence of a field in the map
or a specific value:

| Example    | Meaning                             |
| ---------- | ----------------------------------- |
| `m:foo`    | True if `m` contains the key "foo". |
| `m.foo:*`  | True if `m` contains the key "foo". |
| `m.foo:42` | True if `m.foo` is 42.              |

There are two slight distinctions when parsing messages:

- When traversing messages, a field is only considered to be present if it has
  a non-default value.
- When traversing messages, field names transparently convert between camel
  case and snake case.

### Functions

The filtering language supports a function call syntax in order to support
API-specific extensions. An API **may** define a function using the
`call(arg...)` syntax, and **must** document any specific functions it
supports.

<!-- prettier-ignore-start -->
[aip-132]: ./0132.md
[cel]: https://github.com/google/cel-spec
[cel-cpp]: https://github.com/google/cel-cpp
[cel-go]: https://github.com/google/cel-go
[durations]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/duration.proto
[ebnf grammar]: ../assets/misc/ebnf-filtering.txt
[rfc-3339]: https://tools.ietf.org/html/rfc3339
[timestamps]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/timestamp.proto
<!-- prettier-ignore-end -->
