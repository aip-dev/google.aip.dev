---
aip:
  id: 8
  state: approved
  created: 2019-05-28
  modified: 2019-06-03
permalink: /8
redirect_from:
  - /08
  - /008
  - /0008
---

# AIP Style guide

AIP stands for **API Improvement Proposal**, which is a design document
providing high-level, concise documentation for API development. The goal is
for these documents to serve as the source of truth for API-related
documentation at Google and the way API teams discuss and come to consensus on
API guidance.

AIPs are most useful when they are clear and concise, and cover a single topic
or inquiry well. In the same way that AIPs describe consistent patterns and
style for use in APIs, they also _follow_ consistent patterns and style.

## Guidance

AIPs **must** cover a single, discrete topic, and **should** fundamentally
answer the question, "What do I do?" with actionable guidance. AIPs **may**
also cover what _not_ to do, but **should not** cover _only_ anti-patterns.

While the length of AIPs will necessarily vary based on the complexity of the
question, most AIPs **should** be able to cover their content in roughly two
printed pages.

### File structure

AIPs **must** be written in Markdown, and **must** be named using their
four-digit number (example: `0008.md`). AIPs that serve a specific scope
**must** be in the subdirectory for that scope.

AIPs **must** have appropriate front matter.

```yaml
---
aip:
  id: 8
  state: reviewing
  created: 2019-05-28
permalink: /8
redirect_from:
  - /08
  - /008
  - /0008
---

```

Front matter for AIPs **must** include:

- The `aip` key:
  - `id`: Required. The ID for the given AIP, as an integer.
  - `state`: Required. The current state of the AIP, in all lower-case. The
    valid states are listed in [AIP-1][], and common states are `draft`,
    `reviewing`, and `approved`.
  - `created`: Required. The ISO-8601 date (`yyyy-mm-dd`) when the AIP was
    originally drafted, with no quotes.
  - `updated`: The ISO-8601 date (`yyyy-mm-dd`) when the AIP was last revised.
  - `scope`: The scope for the AIP. This **must** match the directory name for
    that scope. Required for AIPs with IDs >= 1000, prohibited otherwise.
- The `permalink` key (required): This **must** be set to
  `/{aip.scope}/{aip.id}`. If there is no scope, use `/{aip.id}` instead.
- The `redirect_from` key: This should include a list of any `/{aip.id}`
  permutations that a reader would be likely to enter, including:
  - `/{aip.id}` (for AIPs where the permalink includes the scope)
  - AIP IDs with zero-padding, for each level of zero-padding up to four digits
    (for example: `/08`, `/008`, `/0008`).

### Document structure

AIPs **must** begin with a top-level heading with the AIP's title (`# Title`).
The title **should** be a noun (not an imperative). For example, "Bad API
precedents" not "Avoid breaking API precedent".

AIPs **should** then begin with an introduction (with no additional heading),
followed by a `## Guidance` heading. If necessary, the AIP **may** include any
of the following after the guidance, in the following order:

- "Further reading" is a bulleted list of links to other AIPs that are useful
  to fully understand the current AIP.
- "Appendices" covering further explanation in the same AIP. These are
  relatively rare but are important in cases where an AIP requires a lot of
  justification for the decision. Often this is primarily an explanation of
  alternatives considered to help explain the guidance.
- "Changelog" is a bulleted list of changes made to the AIP since the first
  writing.

The guidance section **may** include subsections that elaborate further on
details. Subsections will automatically create an entry in the table of
contents, and an anchor for citations.

Below is an example AIP shell that uses each major section:

```md
# AIP title

The introductory text explains the background and reason why the AIP exists. It
lays out the basic question, but does not tell the reader what to do.

## Guidance

The "guidance" section helps the reader know what to do. A common format for
the guidance section is a high-level imperative, followed by an example,
followed by a bulleted list explaining the example.

### Subsection

Individual subsections can be cited individually, and further elaborate
details.

## Further reading

A bulleted list of (usually) other AIPs, in the following format:

- [AIP-1](./0001.md): AIP purpose and guidelines

## Appendix

An appendix is appropriate when a non-trivial side discussion is necessary. It
may explain historical reasons for the guidance, alternatives considered, or
other issues potentially of interest to the reader.

## Changelog

A bulleted list of changes in reverse chronological order, using the following
format:

- **2020-02-18**: Specified ordering.
- **2019-07-01**: Added a subsection clarifying XYZ.
```

AIPs **should** attempt to follow this overall format if possible, but AIPs
**may** deviate from it if necessary (in particular, if the AIP would be more
difficult to understand, even for a reader already accustomed to reading AIPs
in the usual format).

**Note:** Except for the title, AIPs **must** only use the second heading level
(`##`) and above. AIPs **should** only use the second and third heading levels
(`##`, `###`).

### Requirement keywords

AIPs **should** use the following requirement level keywords: "MUST", "MUST
NOT", "SHOULD", "SHOULD NOT", and "MAY", which are to be interpreted as
described in [RFC 2119][].

When using these terms in AIPs, they **must** be lower-case and **bold**. These
terms **should not** be used in other ways.

**Important:** If an appendix is used, it exists to provide background and a
more complete understanding, but **must not** contain guidance (and RFC-2119
terms **must not** be used).

### Code examples

API design examples in AIPs **should** use [protocol buffers][]. Examples
**should** cover only enough syntax to explain the concept. When using RPCs in
examples, a `google.api.http` annotation **should** be included.

### Referencing AIPs

When AIPs reference other AIPs, the prosaic text **must** use the format
`AIP-XXXX` without zero-padding (e.g., `AIP-8`, not `AIP-0008`), and **must**
link to the relevant AIP. AIP links **may** point to a particular section of
the AIP if appropriate.

### Static AIP Reference

Most times, you will likely want to use a Context Based Reference when
providing a link to an AIP (see below). However it's worth noting that there
may be times when you want to refer to a specific AIP from a specific context,
regardless of what context you are in.

For example, an organization based AIP may extend AIP-121 by stating that
everything in the parent AIP-121 is valid, and that the context based AIP-121
only provides some additional requirements. In this case, the organization
level AIP-121 would want to provide a link to the domain level AIP-121. If the
link were a Context Base Reference, the AIP link to AIP-121 would just link
back to the organization level AIP!

The section below discusses context based references in more detail, and
provides examples of how these links should be implemented. This section is
provided for context for these examples, as the implementation examples cannot
really be shared without consider both types of references together.

### Context Based References

It is not uncommon for AIPs to have relationships or even dependencies on one
another. For example, it may be logical for some implementations of AIP-131
(Methods: GET) to reference AIP-121 (Resource Names), as the address used by
the method should follow the guidelines for resource naming. It may also be
possible for each of these AIPs to be overridden at an organizational level,
yet still maintain their relationship one with another.

In such a case, it would be important that the links between these two AIPs
took into consideration that context under which they were being viewed. For
example if AIP-131 was being viewed under the organization context, then all
links to AIP-121 should point to the organizational extension of AIP-121, and
not the domain level implementation of AIP-121. Likewise, if AIP-121 is being
viewed at the domain level, then links to AIP-131 should point to the domain
level implementation of AIP-131, and not to any organizational extensions.

All AIP reference links that need to take context into consideration **must**
be implemented as follows:

Note: Still brainstorming some ideas, leave feedback:

#### Includes

Idea here is to use a custom \_includes file that will generate the url based
on whether or not there is a context level implementation or not.

**What the AIP Editor Adds**

```
{{ include aip_ref.html aip=131}}
```

**What the solution looks like** This is fairly pseudo codey. I confirmed
there's a way to do this, but am not going to go write perfect code

```
<script>
  const context = localStorage.get("context")
  if (context and {{ file_exists("/"$context"/"aip)}})
    window.getElementById("{{ aip }}").setAttribute("href", `/${context}/aip.md`)
  else
    window.getElementById("{{ aip }}").setAttribute("href", `./aip.md`)
</script>
<a id="{{ aip }}">AIP-{{ aip }}</a>
```

Pros:

- Pretty clean implementation from the client's perspective
- Implementing a static reference would be straight forward

Cons

- utilizes includes, which is slow

#### Automagic

Automatically looks at local refs to see if they exist.

**What the AIP Editor Adds**

```
./0131.md
```

**What the solution looks like** Javascript file that is added to each aip
file:

```
$.when($.ready)(() => {
  const context = localStorage.get("context")

  const anchors = window.getElementById("aip-main").getElementsByTagName("a")
  let href
  for(i = 0; i anchors.length; i++) {
    href = anchors.getAttribute("href")

    if( href is relative) {
      if({{ file_exits("/"context"/"href) }})
        use /context/href
      else
        use ./href
    }
  }
})
```

Pros:

- client does not have to do anything for context based references

Cons:

- client will need to do something different for static references
- javascript iterates over all the anchors in the aip-main element, and
  potentially alters them. This is just more overhead when loading a page. Not
  huge, but still there.
- feels a little hackish.

#### Class Based

Takes advantage of a kramdown feature for providing css classes to links
inline.

**What the AIP Editor Adds** Must be done when defining the reference:

```
[This][]{.context} is a context based reference.
[This][]{.static} is a static reference.
```

**What the implementation looks like** implementation mostly looks like the
automagical one, except we are looking for this class.

```
$.when($.ready)(() => {
  const context = localStorage.get("context")

  const anchors = window.getElementById("aip-main").getElementsByClass("context")
  let href
  for(i = 0; i anchors.length; i++) {
    href = anchors.getAttribute("href")

    if( href is relative) {
      if({{ file_exits("/"context"/"href) }})
        use /context/href
      else
        use ./href
    }
  }
})
```

Pros:

- declarative, similar solution for both static and context based references
- optional, although the aip editor **should** use the declarative solution, if
  they don't we can still treat the default as `static`.
- feels less hackish as it takes advantage of existing functionality.

Cons:

- tighter coupling with kramdown.

#### Failover Redirects

Worth mentioning, but I have not gone too deep into it as I have the above
solutions. We can also write our own `redirect.html` file in the `_layouts`
directory and may be able to add some logic to fail over to a parent AIP if the
context based one doesn't work.

Pros:

- Way to determine whether an AIP reference is context based or static may be
  allowed to be more arbitrary and easier for aip editor to implement.

Cons:

- redirects in GitHub pages can only be done via meta-refresh. If a context
  mostly inherits from it's parent except for one or two files, that means that
  the request process for most context based AIP references would be as
  follows:

1. Request non existent page
2. Jekyll redirects to our custom redirect page
3. redirect page is returned to the browser, client should not see if it fall
   goes well.
4. redirect page creates new request for parent page.

- The above process could be a pain if there are multiple parents (i.e. an
  extension of an extension).

**Important:** AIP links **must** use the relative path to the file in the
repository (such as `./0008.md` for core AIPs, or `../0008.md` for AIPs in a
subdirectory); this ensures that the link works both on the AIP site, when
viewing the Markdown file on GitHub, using the local development server, or a
branch.

[aip-1]: ./0001.md
[protocol buffers]: https://developers.google.com/protocol-buffers/
[rfc 2119]: https://www.ietf.org/rfc/rfc2119.txt

## Changelog

- **2020-02-18**: Specified reverse chronological ordering for changelog items.
- **2019-08-23**: Added guidance for internal AIP links.
