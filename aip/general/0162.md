---
id: 162
state: approved
created: 2019-09-17
placement:
  category: design-patterns
  order: 88
---

# Resource Revisions

Some APIs need to have resources with a revision history, where users can
reason about the state of the resource over time. There are several reasons for
this:

- Users may want to be able to roll back to a previous revision, or diff
  against a previous revision.
- An API may create data which is derived in some way from a resource at a
  given point in time. In these cases, it may be desirable to snapshot the
  resource for reference later.

**Note:** We use the word _revision_ to refer to a historical reference for a
particular resource, and intentionally avoid the term _version_, which refers
to the version of an API as a whole.

## Guidance

APIs **may** store a revision history for a resource. Examples of when it is
useful include:

- When it is valuable to expose older versions of a resource via an API. This
  can avoid the overhead of the customers having to write their own API to store
  and enable retrieval of revisions.
- Other resources depend on different revisions of a resource.
- There is a need to visualize the change of a resource over time.

APIs implementing resources with a revision history **should** abstract resource
revisions as nested collection of the resource. Sometimes, the revisions
collection can be a top level collection, exception includes:

- If resource revisions are meant to have longer lifespan than the parent
resource. In other words, resource revisions exist after the resource deletion.

The resource revision type
**must** inherit from the parent resource and has a field being the parent
resource type.

```proto
message BookRevision {
   // The name of the book revision.
   string name = 1;

   // The snapshot of the book
   Book book = 2 [(google.api.field_behavior) = IMMUTABLE];

  // The timestamp that the revision was created.
  google.protobuf.Timestamp create_time = 3
    [(google.api.field_behavior) = OUTPUT_ONLY];

  // tags set on the resource revisions by service or user.
  repeated string tags = 4;
  [(google.api.field_behavior) = OUTPUT_ONLY];
}
```

- The resource revision **must** contain a field with a message type of the
  parent resource, with a field name of the resource singular.
- The resource revision **must** contain a `create_time` field (see [AIP-142][]).
- The resource revision **may** contain a repeated field `tags` to represent
  tags that was set on the resource revision.

### Creating Revisions

Depending on the resource, different APIs may have different strategies for
when to create a new revision, such as:

- Create a new revision any time that there is a change
- Create a new revision when something important happens
- Create a new revision when the user specifically asks

APIs **may** use any of these strategies. APIs that want to create a revision on
user request **must** handle this with a custom method on the resource:

```proto
rpc TagBookRevision(TagBookRevisionRequest) returns (BookRevision) {
  option (google.api.http) = {
    post: "/v1/{name=publishers/*/books/*}:tagRevision"
    body: "*"
  };
}

message TagBookRevisionRequest {
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference) = {
      type: "library.googleapis.com/Book"
    }];

  // If set, the specified id will be used. Otherwise, a random
  // ID will be provided.
  string revision_id = 2 [(google.api.field_behavior) = OPTIONAL];
  // If set, rather than use the current resource configuration as the resource,
  // the configuration in the source revision will be used.
  //
  // This is helpful when one wants to set an alias for the resource, such as
  // `CURRENT`
  string source_revision_id = 3 [(google.api.field_behavior) = OPTIONAL];
}
```

- The method **must** use the `POST` HTTP verb.
- The method **should** return a resource revision.
- The request message **must** include the `name` field.
- The resource ID of the resource revision **should** be a string and contain a
  short, automatically-generated random string. A good rule of thumb is the last
  eight characters of a [UUID version 4 (random)](UUID4).
- `tag` field is optional. If provided, revision created will have the tag set.

### Resource names for revisions

Revisions **must** exist in a subcollection of the original resource. When
referring to specific revision of a resource, the subcollection name **must**
named `revisions`. Resource revisions have names with the format
 `{resource_name}/revisions/{revision_id}`. For example:

publishers/123/books/les-miserables/revisions/c7cfa2a8

### Revision IDs

There are two types of tags: server and user specified.

#### Server specified

Services **may** reserve specific tags to be server-specified (e.g. `current`,
`latest`), which are read-only and managed by the service.

- If a `latest` tag exists, it **must** represent the most recently created
  revision.
 The content of `publishers/{publisher}/books/{book}/revisions/latest` and
  `publishers/{publisher}/books/{book}` can differ. Because the latest revision
  may be different from the current state of the resource.

```
GET /v1/publishers/{publisher}/books/{book}/revisions/{reserved_id}
```

#### User specified

User specified tags are tags provided by the user when tagging specific resource
revision.

APIs implementing resource revisions **may** provide a mechanism for users to
tag a specific revision with a user provided name by implementing a "Tag
Revision" custom method:

```proto
rpc TagBookRevision(TagBookRevisionRequest) returns (Book) {
  option (google.api.http) = {
    post: "/v1/{name=publishers/*/books/*/revisions/*}:tag"
    body: "*"
  };
}
```

```proto
message TagBookRevisionRequest {
  // The name of the book revision to be tagged.
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference) = {
      type: "library.googleapis.com/BookRevision"
    }];

  // The tag to apply. The tag should be at most 40 characters, and match
  // `[a-z][a-z0-9-]{3,38}[a-z0-9]`.
  string tag = 2 [(google.api.field_behavior) = REQUIRED];
}
```
- The `name` field **should** require an explicit resource revision to be
  provided.
  - The field **should** be [annotated as required][aip-203].
  - The field **should** identify the [resource type][aip-123] that it
    references.
- The `tag` field **should** be [annotated as required][aip-203].
  - Additionally, tags **should** restrict letters to lower-case.
- Once a revision is tagged, the API **must** support using the tag in place of
  the revision ID in `name` fields.
  - If the user sends a tag or revision ID, the API **must** return the revision
    ID in the resource's `name` field.
- If the user calls the `Tag` method with an existing tag, the request **must**
  succeed and the tag updated to point to the new requested revision ID. This
  allows users to write code against specific tags (e.g. `published`) and the
  revision can change in the background with no code change.

### Getting a revision

Services `must` implement the standard `Get` method ([AIP-131][])

## Listing revisions

Services `must` implement the standard `List` method ([AIP-132][])

- By default, revisions in the list response **must** be ordered in reverse
  chronological order. User can supply `order_by` to override the default
  behavior.

### Child resources

Resources with a revision history **may** have child resources. If they do,
there are two potential variants:

- Child resources where each child resource is a child of the parent resource
  as a whole.
- Child resources where each child resource is a child of _a single revision
  of_ the parent resource.

APIs **should not** include multiple levels of resources with revisions, as
this quickly becomes difficult to reason about.

### Rollback

A common use case for a resource with a revision history is the ability to roll
back to a given revision. APIs **should** handle this with a `Rollback` custom
method:

```proto
rpc RollbackBook(RollbackBookRequest) returns (BookRevision) {
  option (google.api.http) = {
    post: "/v1/{name=publishers/*/books/*}:rollback"
    body: "*"
  };
}
```

- The method **must** use the `POST` HTTP verb.
- The method **should** return a resource revision.

```proto
message RollbackBookRequest {
  // The book being rolled back.
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference) = {
      type: "library.googleapis.com/Book"
    }];

  // The revision ID to roll back to.
  // It must be a revision of the same book.
  //
  //   Example: c7cfa2a8
  string revision_id = 2 [(google.api.field_behavior) = REQUIRED];
}
```

- The request message **must** have a `name` field to identify the resource
  being rolled back.
  - The field **should** be [annotated as required][aip-203].
  - The field **should** identify the [resource type][aip-123] that it
    references.
- The request message **must** include a `revision_id` field.
  - The API **must** fail the request with `NOT_FOUND` if the revision does not
    exist on that resource.
  - The field **should** be [annotated as required][aip-203].

**Note:** When rolling back, the API should return a _new_ revision of the
resource with a _new_ revision ID, rather than reusing the original ID. This
avoids problems with representing the same revision being active for multiple
ranges of time.

### Deleting revisions

Revisions are sometimes expensive to store, and there are valid use cases to
want to remove one or more revisions from a resource's revision history.

As revisions are nested under the resource, also see [cascading delete][].

## Rationale

### Abstract revisions as nested collection

Revisions being resources under nested collection make revisions a first class
citizen.

- Revisions can offer standard get, list, and delete methods.
- Revision has its own separate message type and inherits from the parent
  resource type. It retains the flexibility of extending new fields to revision
  resources.

### Consolidation of tagging use cases

Previously, committing and tagging a resource were two separate methods on a
resource, enabling the following user journeys:

- Commit
  - Creating a revision with the current resource configuration.
- Tag
  - Taking an existing revision and giving it an alias.

Tagging is effectively giving a second resource ID to a revision.

## History

### Switching from from a collection extension to a subcollection

In 2023-07, revisions are abstracted as nested resource. Prior to this,
revisions are more like extension of an existing resource by using `@` symbol.
List and delete revisions are custom method on the resource collection. Getting
revision shares the same method with get resource.

It had several advantages:

- A resource reference could seamlessly refer to a resource, or it's revision.

It also had several disadvantages:

-  List revisions is a custom method (:listRevisions) on the resource collection
-  Delete revision is a custom method on the resource collection
-  Not visible in api discovery doc
-  Resource ID cannot use `@`

The guidance was modified ultimately to enable revisions to behave like a
resource, which reduces the users cognitive load and allows resource-oriented
clients to easily list, get, create, and update revisions.

### Using resource ID instead of tag

In, revisions had a separate identifer for a revision known as a `tag`,
that would live in a revision.

Tags were effectively a shadow resource ID, requiring methods to create, get and
filter revisions based on the value of the tag.

By consolidating the concept of a tag into the revision ID, the user no longer
needs to be familiar with a second set of retrieval and identifier methods.


## Changelog

- **2023-08-07**: AIP was updated to be a sub-collection rather.
- **2021-04-27**: Added guidance on returning the resource from Delete Revision.

[aip-123]: ./0123.md
[aip-131]: ./0131.md
[aip-132]: ./0132.md
[aip-135]: ./0135.md
[aip-142]: ./0142.md
[aip-203]: ./0203.md
[cascading delete]: ./0135.md#cascading-delete
[UUID4]: https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)
