---
id: 162
state: approved
created: 2019-09-17
placement:
  category: design-patterns
  order: 88
---

# Resource Revisions

Some APIs need to have resources with a revision history, where users can
reason about the state of the resource over time. There are several reasons for
this:

- Users may want to be able to roll back to a previous revision, or diff
  against a previous revision.
- An API may create data which is derived in some way from a resource at a
  given point in time. In these cases, it may be desirable to snapshot the
  resource for reference later.

**Note:** We use the word _revision_ to refer to a historical reference for a
particular resource, and intentionally avoid the term _version_, which refers
to the version of an API as a whole.

## Guidance

APIs **may** store a revision history for a resource if it is useful to users.

APIs implementing resources with a revision history **should** abstract resource revisions as nested collection of the resource. The
resource revision type **must** inherit from the parent resource and has a field being the parent resource type.

```proto
message BookRevision {
   // The name of the book revision.
   string name = 1;

   // The snapshot of the book
   Book book = 2 [(google.api.field_behavior) = IMMUTABLE];

  // The timestamp that the revision was created.
  google.protobuf.Timestamp create_time = 3
    [(google.api.field_behavior) = OUTPUT_ONLY];

  // tags set on the resource revisions by service or user.
  repeated string tags = 4;
  [(google.api.field_behavior) = OUTPUT_ONLY];
}
```

- The resource revision **must** contain a field representing the snapshot of the parent resource.
- The resource revision **must** contain a `create_time` field, which
  **must** be a `google.protobuf.Timestamp` (see [AIP-142][]).
- The resource revision **may** contain a repeated field `tags` to represent tags that was set on the resource revision.

### When resource revisions are useful

- When it is valuable to expose older versions of a resource via an API. This can avoid the overhead of the cusotmers having to write their own API to store and enable retrieval of revisions.
- Oher resources depend on different revisions of a resource.
- There is a need to visualize the change of a resource over time.

### Resource names for revisions

When referring to specific revision of a resource, APIs must use the following syntax
`{resource_name}/revisions/{revision_id}`. For example:

publishers/123/books/les-miserables/revisions/c7cfa2a8

### Getting a revision

Services `should` implement the standard `Get` method ([AIP-131][])

### Tagging revisions

There are two types of tags: server defined and user specified.

#### Server defined

Services **may** reserve specific tags to be server-defined (e.g. `current`, `latest`), which are read-only and managed by the service.

- `latest` represents the most recent created revision. The content of `publishers/{publisher}/books/{book}/revisions/latest` and `publishers/{publisher}/books/{book}` can differ. Because the latest revision may be different from the current state of the resource.

```
GET /v1/publishers/{publisher}/books/{book}/revisions/{reserved_keyword}
```

#### User Specified

User specified tags are tags provided by the user when tagging specific resource revision.

APIs implementing resource revisions **may** provide a mechanism for users to
tag a specific revision with a user provided name by implementing a "Tag
Revision" custom method:

```proto
rpc TagBookRevision(TagBookRevisionRequest) returns (Book) {
  option (google.api.http) = {
    post: "/v1/{name=publishers/*/books/*/revisions/*}:tag"
    body: "*"
  };
}
```

```proto
message TagBookRevisionRequest {
  // The name of the book revision to be tagged.
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference) = {
      type: "library.googleapis.com/BookRevision"
    }];

  // The tag to apply.
  // The tag should be at most 40 characters, and match `[a-z][a-z0-9-]{3,38}[a-z0-9]`.
  string tag = 2 [(google.api.field_behavior) = REQUIRED];
}
```
- The `name` field **should** require an explicit resource revision to be provided.
  - The field **should** be [annotated as required][aip-203].
  - The field **should** identify the [resource type][aip-123] that it
    references.
- The `tag` field **should** be [annotated as required][aip-203].
  - Additionally, tags **should** restrict letters to lower-case.
- Once a revision is tagged, the API **must** support using the tag in place of
  the revision ID in `name` fields.
  - If the user sends a tag or revision ID, the API **must** return the revision ID in the resource's
    `name` field.
- If the user calls the `Tag` method with an existing tag, the request **must**
  succeed and the tag updated to point to the new requested revision ID. This
  allows users to write code against specific tags (e.g. `published`) and the
  revision can change in the background with no code change.
### Listing revisions

Services `should` implement the standard `List` method ([AIP-132][])


- By default, revisions in the list response **must** be ordered in reverse chronological order. User can supply `order_by` to override the default behavior.

### Child resources

Resources with a revision history **may** have child resources. If they do,
there are two potential variants:

- Child resources where each child resource is a child of the parent resource
  as a whole.
- Child resources where each child resource is a child of _a single revision
  of_ the parent resource.

If a child resource is a child of a single revision, the child resource's name
**must** always explicitly include the parent's revision ID:

    publishers/123/books/les-miserables/revisions/c7cfa2a8/pages/42

If necessary, APIs **may** explicitly support listing child resources across
parent revisions by accepting the `-` syntax. For example:

    GET /v1/publishers/123/books/les-miserables/revisions/-/pages

APIs **should not** include multiple levels of resources with revisions, as
this quickly becomes difficult to reason about.

### Committing revisions

Depending on the resource, different APIs may have different strategies for
when to commit a new revision, such as:

- Commit a new revision any time that there is a change
- Commit a new revision when something important happens
- Commit a new revision when the user specifically asks

APIs **may** use any of these strategies. APIs that want to commit a revision on user request should
handle this with a custom method on the resource:

```proto
rpc CommitBookRevision(CommitBookRevisionRequest) returns (BookRevision) {
  option (google.api.http) = {
    post: "/v1/{name=publishers/*/books/*}:commitRevision"
    body: "*"
  };
}

message CommitBookRequest {
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference) = {
      type: "library.googleapis.com/Book"
    }];
  string tag = 2 [(google.api.field_behavior) = OPTIONAL];
}
```

- The method **must** use the `POST` HTTP verb.
- The method **should** return a long running operation or resource revision.
- The request message **must** include the `name` field.
- The resource ID of the resource revision **should** be a
  string and contain a short, automatically-generated random string. A good
  rule of thumb is the last eight characters of a [UUID version 4 (random)](UUID4).
- `tag` field is optional. If provided, revision created will have the tag set.

### Rollback

A common use case for a resource with a revision history is the ability to roll
back to a given revision. APIs **should** handle this with a `Rollback` custom
method:

```proto
rpc RollbackBook(RollbackBookRequest) returns (BookRevision) {
  option (google.api.http) = {
    post: "/v1/{name=publishers/*/books/*}:rollback"
    body: "*"
  };
}
```

- The method **must** use the `POST` HTTP verb.
- The method **should** return a long running operation or resource revision.

```proto
message RollbackBookRequest {
  // The book being rolled back.
  string name = 1 [
    (google.api.field_behavior) = REQUIRED,
    (google.api.resource_reference) = {
      type: "library.googleapis.com/Book"
    }];

  // The revision ID to roll back to.
  // It must be a revision of the same book.
  //
  //   Example: c7cfa2a8
  string revision_id = 2 [(google.api.field_behavior) = REQUIRED];
}
```

- The request message **must** have a `name` field to identify the resource
  being rolled back.
  - The field **should** be [annotated as required][aip-203].
  - The field **should** identify the [resource type][aip-123] that it
    references.
- The request message **must** include a `revision_id` field.
  - The API **must** fail the request with `NOT_FOUND` if the revision does not
    exist on that resource.
  - The field **should** be [annotated as required][aip-203].

**Note:** When rolling back, the API should return a _new_ revision of the
resource with a _new_ revision ID, rather than reusing the original ID. This
avoids problems with representing the same revision being active for multiple
ranges of time.

### Deleting revisions

Revisions are sometimes expensive to store, and there are valid use cases to
want to remove one or more revisions from a resource's revision history.

APIs **may** define a standard `Delete` ([AIP-135][]) method to delete resource revisions

- Resource revisions **should** be automatically deleted on parent resource deletion.
- If resource revisions meant to have longer lifespan than the parent resource, resource and resource revision
should be side by side resource collections.

## Rationale

### Deprecate the @-based approach

Historically, Resource revision was recommended to be referenced by `{resource_id}@{revision_id}`.

It has several disadvantages:

-  List revisions is a custom method (:listRevisions) on the resource collection
-  Delete revision is a custom method on the resource collection
-  Not visible in api discovery doc
-  Resource ID cannot use `@`

### Abstract revisions as nested collection

Revisions being resources under nested collection make revisions a first class citizen. 

- Revisions can offer standard get, list, and delete methods.
- Revision has its own separate message type and inherits from the parent resource type. It retains the flexibility of extending new fields to revision resources.

## History

In 2023-06, revisions are abstracted as nested resource. Prior to this, revisions are more like extension of an existing resource by using `@` symbol. List and delete revisions are custom method on the resource collection. Getting revision shares the same method with get resource.

## Changelog

- **2023-06-21**: Added a new AIP version of resource revisions.
- **2021-04-27**: Added guidance on returning the resource from Delete Revision.

[aip-123]: ./0123.md
[aip-131]: ./0131.md
[aip-132]: ./0132.md
[aip-135]: ./0135.md
[aip-142]: ./0142.md
[aip-203]: ./0203.md
[UUID4]: https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)
