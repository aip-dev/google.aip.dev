---
id: 3270
scope: firebase
state: draft
created: 2020-06-10
---

# JavaScript APIs

## Guidance

### User Interfaces
Core Firebase APIs **should** not expose their own user interfaces - they **should** be pure programmatic APIs that the developer can use to expose their own interfaces. The only exceptions to this rule are APIs which can expose interfaces that are integral to other pre-existing services (e.g., bringing up sign-in APIs for authenticating users to a particular service).

### Naming Conventions
Identifiers **should** follow the below formats by identifier type.
```
functionNamesLikeThis
variableNamesLikeThis
ClassNamesLikeThis
EnumNamesLikeThis
TypedefsLikeThis
methodNamesLikeThis
CONSTANT_VALUES_LIKE_THIS
foo.namespaceNamesLikeThis.bar
```

If part of your name is an acronym (`HTTP`, `XML`, `URL`) or abbreviations (`id`). In the context of JavaScript APIs there is not a simple rule that fits all; certain acronyms tend to be all upper case, and others can be initial capital (in no event should the initial letter of a symbol NOT follow the general naming conventions above, however).
```
// Preferred forms of acronyms or abbreviations in symbols:
xml or XML
url or URL
http or Http
uid or Uid
id or Id
```

Identifier names **should** not be prefixed with `firebase` or product names, e.g. `firestore`, `auth` unless doing so causes conflicts with global identifers. Even in such cases, It is prefered to rename the identifier to something different instead of prefixing it with `firebase` or product names.

Function names **should** not start with `use` to avoid being recognized as React hooks and causing lint errors when used in React apps.

### Type Naming Convention
// TODO
### Use Promises For Single Asynchrounous Values
APIs **should** return `Promises` for asynchronous single values as apposed to nested callbacks. If a legacy API is already using callback to return results, consider also returning a Promise as a means of eventually deprecating the fallback behavior.

`Promises` **should** be rejected by an object that is a subclass of Error (see Error Handling section, below).
### Asynchronous Events (Streams)
We want to encourage an event model that is composable with event filters and processors.

Looking at the ReactiveJS spec, we notice that we can implement a simple version of the basic Subscribe interface, and be compatible with other Reactive components and libraries (while preserving the simplicity of implementation for non-Reactive users).

The basic types in the Observer/Observable pattern are:
```javascript
type NextFn<T> = (value: T) => void;
type ErrorFn = (error: Error) => void;
type CompleteFn = () => void;

// An Observer implements any of these methods - and can be the recipient
// of events in an event stream.  Note that exactly ONE of onError or onCompleted
// are called when the event source is terminated.
interface Observer<T> {
  next?: NextFn<T>;
  error?: ErrorFn;
  complete?: CompleteFn;
}

type Unsubscribe = () => void | interface { unsubscribe(): void };

// A Subscribe function is how you bind to an event source.  Note that it
// can either take a single Observer parameter, or 1 to 3 callback functions
// (in onNext, onError, onCompleted order).
type Subscribe<T> = (observer: Observer<T> | NextFn<T>,
                     error?: ErrorFn,
                     complete?: CompleteFn) => Unsubscribe;

// To un-subscribe an Observer, just call the returned Unsubscribe function.

export interface Observable<T> {
  subscribe: Subscribe<T>;
}

// We also guarantee that none of the Observer methods are called synchronously
// … the subscribe function returns strictly BEFORE any Observer methods can
// be called.
```
There are three ways you **may** expose an event stream in your API:
```javascript
// #1 My object is a simple Observable
class MyObject implements Observable<Type> {
  subscribe: Subscribe<Type> = (...) => { … }
}

// Callers use like this:
obj.subscribe((value) => { … });   // Just consume onNext events.
obj.subscribe({                     // Consume events and notifications.
  next: { … },
  error: { … },
  complete: { … }
});

// More concisely:
obj.subscribe(onNext, onError, onCompleted);
obj.subscribe(observer);

// #2 My object has one or more named Subscribe methods
class MyObject {
  onChildAdded: Subscribe<Type> = (...) => {...}
  onChildRemoved: Subscribe<Type> = (...) => {...}
}

// Callers use like this:
obj.onChildAdded(next, error, complete);
obj.onChildAdded(observer);

// #3 My Object allows selecting an event source by (string) name:
// (this style will look more familiar to JavaScript developers not
// familiar with Reactive patterns).
class MyObject {
  on: OnMethod = ( … ) => { … }
}

type OnMethod = (eventType: string,
                 observer: Observer<any> | NextFn<any>,
                 error?: ErrorFn,
                 complete?: CompleteFn) => Subscribe | Unsubscribe;

// The traditional style allows in-line declaration of the Observer methods.
obj.on('child_added', next, error, complete);
obj.on('child_added', observer);

// The Reactive style uses this method with a single string parameter
// to get a Subscribe function.
obj.on('child_added')(observer);
obj.on('child_added')(next, error, complete);
```

Note that the `Unsubscribe` function **should** be returned to the caller of a `Subscribe`. To ensure that it would also be available within the callbacks (in the closure), you **should** avoid calling any of the Observer functions synchronously even if you have data available immediately.

### Error Handling
Warning and error message **must** help developers understand and resolve the error or address the warning easily and quickly.

In order to be useful, every warning & error message:

- **MUST** identify the origin — so the developer knows which software component and subsystem produced the message
- **MUST** explain the problem — in terms that are helpful (concise, human readable) to the developer
- **MUST** offer at least one solution — so the developer knows what action to resolve the problem

Synchronous functions **may** return errors via thrown exceptions. It is **not** recommended that APIs treat normal conditions (like attempting to lookup a missing value in a dictionary) as exceptions; use a return value of `null` (or `undefined`) instead.

Asynchronous operations **should** use `Promise.reject`.

All thrown exceptions **should** be `FirebaseError` or a subclass of the `FirebaseError`. Required properties **should** include:
```
message: "A user-displayable message describing the error, which includes (go/developer-error-messages): the source of the error, the root cause and at least one recommended solution or follow up."
code: "string-error-code"
```

The machine-readable code property **should** be a small (less than 32 character) string containing lower-case ascii letters, forward slashes and hyphens, that uniquely describes the error which occurred. Clients **may** write code that tests for specific error code results (changes to the error code for a particular error **should** be deemed to be API changes (all returned error codes that are API-specific **should** be documented in the API)).

Error codes **may** contain slashes to classify errors into groups (or by service name). For example:

```
database/illegal-field-name
database/missing-value
request/server-not-found
```
Clients **may** compare the prefix of a code to test for a class of error type.

It is **recommended** that this prefix be used as a unique ID for the Firebase Service generating the error: one of [app, auth, database, storage, firestore, analytics, performance, remote-config, messaging, installations].

In case where your API returns an error code, but there is actually no error, you should return the string `ok`.

### Partial Errors
If you have an Promise-based API that can partially succeed (e.g., successfully deleted 50 out of 100 files requested for deletion), we recommend that you reject the `Promise`, and encapsulate the multiple child errors like this:
```javascript
return new Promise((resolve, reject) => {
  let errors: Error[] = myOperation();
  if (errors.length == 0) {
    resolve(...);
  } else {
    let error = new Error("Failed my-operation with " + errors.length + " errors.");
    error.code = 'my-failure-code';
    error.errors = errors;
    reject(error);
  }
});
```

### Times And Durations
When returning a date you **should** return an [RFC3339 formatted](https://datatracker.ietf.org/doc/html/rfc3339) string.

This has the following benefits:

- Human readable.
- Can be parsed by modern browsers `new Date(time)`.
- Allows timezone information to be included.
- Brings Firebase and One Platform specs inline.

As a naming convention, appending `Time`, e.g., `lastSignedInTime`, **can** be used to make it more clear that the API is not returning a native `Date` value (especially don't use `Date` in the name to avoid confusion).

Durations **should** be defined in milliseconds.

### Prefer Plain JS Objects for API Options
If your API allows for options or metadata that can be passed to a function, prefer to use a plain JavaScript Object instead of requiring callers to use a specific constructed object type with accessor methods.

Instead of this:
```javascript
const options = new Options();
options.setOption1(value);
options.setOption2(value);
myAPI(param, options);
```

Prefer to use this:
```javascript
myAPI(param, {option1: value, option2: value});
```

### Input Validation
Public APIs **should NOT** perform input validations that can be done by `Typescript` at compile time, e.g. the number and type of parameters.

However, they **should** check the validity of all parameters at the point of entry for things like number range, date range that can be only performed at runtime.

Input validation errors **should** be thrown syncronously at the time of the call. For asynchronouse APIs, it means to throw immediately at the call-site, instead of rejecting or calling `error()` callback.

### Prefer exposing Constructors over Factory Methods
Instead of:
```javascript
const x = createThing(param);
```
prefer:
```javascript
const x = new Thing(param);
```
There are places where factory methods are very acceptable. For example, if you are enforcing a singleton pattern, maintain a pool of objects, or if you need to create an object only from the context of a containing object.

### Exporting Symbols from a Package
Packages **must** be written in standard ES module format, and **must** only use named exports to export symbols. Default exports **should** not be used.

### Optional Parameters and Nullable parameters

JavaScript allows for judicious use of "optional" parameters, by allowing terminal arguments to be undefined. If your API grows beyond 3 passed parameters, you should consider passing parameters as optional (named) properties of a plain JS object (see API Options section).

You **should** generally prefer API definitions with non-nullable parameters where possible.

### Accessing Object Properties
When retrieving the portion of state (synchronously) from an Object, the standard in Java to use `getMyProperty()` accessor functions are not recommended - just use `obj.myProperty` instead.

### Properties vs. Zero-Argument Methods
API **should** use property accessor when it:
- Is inexpensive to compute.
- Has no side effects (idempotent).
- Is available synchronously.
- Does not need (optional) additional information to access it.

Otherwise, use zero-argument methods.

### Implement `toJSON()` for complex objects
All `Object-derived` types **should** consider how they will be represented in `console.log` and whether a custom `toJSON()` should be added. Any class with a circular reference **should** consider implementing `toJSON()`. Developers **may** also consider implementing `toJSON()` if there is a layout that makes more sense than a recursive traversal of the object.

If there is a public JSON API, `toJSON()` **should** give the public over-the-wire format.

Changes to the `toJSON()` API **can** be breaking so being conservative is a reasonable approach.

### Partial Success Response
If an API takes an array of items upon which to perform an action and returns a `Promise`, the `Promise` should only be rejected if the entirety of the request cannot be made for some reason, such as an authentication or invalid argument error. If the request can be made, but a subset of the items result in an error (or even if all items result in an error), the Promise should still be fulfilled with a response like the following:

```javascript
type FirebaseArrayIndexError = {
  // The index of the erroring item within the original array.
  index: number;

  // The Firebase error detailing the reason for the failed operation.
  error: FirebaseError;
};

type ExampleResponse = {
  // Number of successful items.
  successCount: number;

  // Number of unsuccessful items.
  failureCount: number;

  // Array of errors for all unsuccessful items.
  errors: FirebaseArrayIndexError[];
}
```
The index property of `FirebaseArrayIndexError` corresponds to the item's index in the original array that was part of the request.
## Changelog
