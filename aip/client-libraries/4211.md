---
aip:
  id: 4211
  scope: client libraries
  state: reviewing
  created: 2018-06-22
  updated: 2019-04-22
permalink: /client-libraries/4211
redirect_from:
  - /4211
---

# Parsing resource names

In [resource-oriented design][aip-121], _resources_ represent the primary nouns
within APIs, and often have [resource names][aip-122]. These resource names
convey information about the structure and hierarchy of the resource structure
in that API. APIs accept these resource names as parameters when retrieving and
modifying resources, and when referencing them in other objects. However, users
may struggle to piece together resource names to send, and client libraries
have the opportunity to make this easier through the use of helper components.

## Guidance

Client libraries **may** provide helper classes or functions to make
constructing resource names more straightforward. However, client libraries
that choose to implement this feature **must** always accept the plain strings
also, for two reasons:

1. An existing API that adds resource descriptor annotations should be able to
   do so without incurring a breaking change.
2. Resource name patterns occasionally evolve, and users need to be able to
   send and receive resource names that a statically-compiled client library
   may not yet acknowledge.

### Resource messages

A resource in an API always has a message that describes the representation of
that resource in that API. Client library generators are able to recognize
these messages when they are annotated with the `google.api.resource`
annotation:

```proto
// A representation of a Topic in Pub/Sub.
message Topic {
  option (google.api.resource) = {
    type: "pubsub.googleapis.com/Topic"
    pattern: "projects/{project}/topics/{topic}"
  };

  // The resource's name.
  string name = 1;

  // And so on...
}
```

- The `type` field provides the [universal resource type][4] name.
  - Client libraries **should** name their helper component based on this
    value.
- The `pattern` field provides the structure of this resource type's names.
  - The components in braces represent variable substitutions. Client libraries
    implementing this feature **must** accept variables based on these names
    when building resource name strings.
  - Variable substitution names are usually specified in `snake_case`, but this
    is not guaranteed. Client libraries **should** be able to accept any
    annotation that uses any sane case system.
  - Patterns are usually slash-separated, but this is not guaranteed. Client
    libraries **should** use string interpolation to piece together the
    resource name.
- The resource is expected to contain a field called `name`, which is the field
  holding the resource name.
  - Code generators **should** fail with an error if a message is annotated as
    a resource and has no `name` field (or has a `name` field that is not a
    string).
  - APIs are able to override the name field's name by setting the `name_field`
    property on the `google.api.resource` annotation.

### Multi-parent resources

Occasionally, a resource may have more than one pattern. The common case for
this is when a resource can live under more than one parent type. In this
situation, the `pattern` field on the annotation can be specified more than
once:

```proto
message LogEntry {
  option (google.api.resource) = {
    type: "logging.googleapis.com/Log"
    pattern: "projects/{project}/logs/{log}"
    pattern: "organizations/{organization}/logs/{log}"
    pattern: "folders/{folder}/logs/{log}"
    pattern: "billingAccounts/{billing_account}/logs/{log}"
  }

  // The resource's name.
  string name = 1;

  // And so on...
}
```

If necessary, client libraries **may** create a separate helper component for
each pattern, and **may** provide a rollup component.

### Referencing other resources

APIs often use resource names for referencing fields defined elsewhere. This is
particularly common with the request messages for the standard methods, such as
[Get][aip-131] and [Update][aip-134]; however, resources and other structures
use resource name strings as references also.

Client libraries implementing this feature **should** also provide their helper
components when resources are being referenced. Client libraries are able to
recognize these fields when they are annotated with the
`google.api.resource_reference` annotation:

```proto
message GetTopicRequest {
  // The name of the topic to retrieve.
  string name = 1 [(google.api.resource_reference) = {
    type: "pubsub.googleapis.com/Topic"
  }];
}
```

The resource reference references the [unified resource type][4] name.

Some methods also refer to the _parent_ of a type, and in situations where
there are multiple parents, it is repetitive and error-prone to refer to each
individual parent type. In these situations, API producers specify `child_type`
rather than `type`:

```proto
message ListLogEntriesRequest {
  // The collection of log entries to list.
  string parent = 1 [(google.api.resource_reference) = {
    child_type: "logging.googleapis.com/LogEntry"
  }];
}
```

In this situation, client library generators implementing this feature **must**
derive the set of parent resources from the child type.

### Backwards compatibility

Client libraries implementing helper components for resources **must** conform
to the following backwards-compatibility expectations:

- The addition of a `google.api.resource` annotation on an existing message
  **must** be a backwards-compatible change.
- An existing resource **must** be able to add new patterns without breaking
  changes as long as the following conditions are met:
  - New patterns must always be appended to the list.
  - If migrating from one pattern to two patterns, the
    `ORIGINALLY_SINGLE_PATTERN` flag is also added.
  - If migrating from one pattern with the the `FUTURE_MULTI_PATTERN` flag set,
    the `ORIGINALLY_SINGLE_PATTERN` flag is _not_ added.
- The addition of a `google.api.resource_reference` annotation on an existing
  field **must** be a backwards-compatible change.

[aip-121]: /aip/0121.md
[aip-122]: /aip/0122.md
[aip-131]: /aip/0131.md
[aip-134]: /aip/0134.md
[4]: https://goto.google.com/unified-resource-types
